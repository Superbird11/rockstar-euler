(Let d{n} be defined as the sum of proper divisors of n {numbers less than n  which divide    )
(evenly into n}. If d{a} = b and d{b} = a, where a â‰  b, then a and b are an amicable pair and )
(each of a and b are called amicable numbers.                                                 )
(                                                                                             )
(For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110;      )
(therefore d{220} = 284. The proper divisors of 284 are 1, 2, 4, 71 and 142; so d{284} = 220. )
(                                                                                             )
(Evaluate the sum of all the amicable numbers under 10000.                                    )

(This is a super inefficient approach to finding proper divisors - caching would help, )
(as would only searching up to sqrt and finding corresponding coefficient. But this is )
(more straightforward to implement, caching is complicated, and sqrt is very hard to   )
(implement by comparison. This takes up to 10 minutes to run on Satriani.              )
SumOfProperDivisors takes num                                 ( func SumOfProperDivisors{num}:                           )
  Let runningSum be nothing                                   (   runningSum = 0                                         )
  Let factor be 1                                             (   factor = 1                                             )
  Until factor is num                                         (   while factor < num:                                    )
    Let divideF be num over factor                            (     divideF = num / factor                               )
    Let divideI be divideF                                    (     divideI = divideF                                    )
    Turn down divideI                                         (     divideI = floor{divideI}                             )
    If divideF is divideI                                     (     if divideF == divideI:                               )
      Let runningSum be with factor                           (       runningSum += factor                               )
    
    Build factor up                                           (     factor ++                                            )
    
  Give back runningSum                                        (   return runningSum                                      )
  
Let idx be 2                                                  ( idx = 2                                                  )
Let limit be 10000                                            ( limit = 10000                                            )
Let finalSum be 0                                             ( finalSum = 0                                             )
Until idx is limit                                            ( while idx < limit:                                       )
  Let sopdForward be SumOfProperDivisors taking idx           (   sopdForward = SumOfProperDivisors{idx}                 )
  Let sopdBackward be SumOfProperDivisors taking sopdForward  (   sopdBackward = SumOfProperDivisors{sopdForward}        )
  If sopdBackward is idx and sopdForward ain't sopdBackward   (   if sopdBackward == idx && sopdForward != sopdBackward: )
    Let finalSum be with idx                                  (     finalSum += idx                                      )

  build idx up                                                (   idx ++                                                 )
  
Shout finalSum                                                ( print{finalSum}                                          )